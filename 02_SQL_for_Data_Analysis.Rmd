---
title: "02 SQL for Data Analysis"
author: "George Melrose"
date: "23/05/2024"
output:
   html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

The concepts outlined by the SQL code below are taken from this LinkedIn learning course, ***"SQL for Data Analysis"*** - <https://www.linkedin.com/learning/sql-for-data-analysis>

```{r setup, include=FALSE}
rm(list = ls())

knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(readr,tidyverse, data.table,DBI,odbc,RSQLite)

options(max.print = 1000) 
getOption("max.print")

con <- dbConnect(SQLite(), dbname = ":memory:")
knitr::opts_chunk$set(connection = "con")


# List the tables present in the database connected through 'con'
tables <- dbListTables(con)

# Print the list of tables
print(tables)
```

```{r reading in data to the pretend database, warning=FALSE, message=FALSE, include=FALSE}
# List of table names (should match the original table names)
tables <- c("author","book_author","book_language","country",
            "customer","customer","customer_address","order_line",
            "order_status","publisher","shipping_method","address","address_status") # Replace with your actual table names

book <- read_csv("book.csv")

book$publication_date <- as.character(book$publication_date)
  
# Write the table to the new SQL connection
dbWriteTable(con, "book", book, overwrite = TRUE)

cust_order <- read_csv("cust_order.csv")

cust_order$order_date <- as.character(cust_order$order_date)
  
# Write the table to the new SQL connection
dbWriteTable(con, "cust_order", cust_order, overwrite = TRUE)
  

order_history <- read_csv("order_history.csv")

order_history$status_date <- as.character(order_history$status_date)
  
# Write the table to the new SQL connection
dbWriteTable(con, "order_history", order_history, overwrite = TRUE)
  
  

# Loop through each table and read it from the CSV file
for (table in tables) {
  # Read the table from the CSV file
  data <- read_csv(paste0(table, ".csv"))
  
  # Write the table to the new SQL connection
  dbWriteTable(con, table, data, overwrite = TRUE)
}



rm(data)

```

```{sql}

select * from book

```

```{sql}

select * from book

```

```{sql }
select * from book_language
```




```{r Print the tables currently in the database, warning=FALSE, message=FALSE, include=FALSE}
# List the tables present in the database connected through 'con'
tables <- dbListTables(con)

# Print the list of tables
print(tables)
```

```{sql list all the tables from the database, include=FALSE}
SELECT name FROM sqlite_master WHERE type='table';
```

```{r gravity bookstore dataset erd png, message=FALSE, warning=FALSE}
knitr::include_graphics("C:/Users/gam55/Downloads/gravity_bookstore_erd.png")

```

## 1 Working with Dates

Key date and time functions in SQLite -

-   DATE() - While SQLite doesn't have a TIMESTAMP function like in MySQL, this function returns the date in 'YYYY-MM-DD' format.

```{sql Using Date function}
SELECT DATE('now') AS "Current Date"; -- returns the current date
```

-   DATETIME() - This function returns the date and time in 'YYYY-MM-DD HH:MM' format.

```{sql Using DateTime function}

SELECT DATETIME('now') AS "Current Date and Time"; -- returns the current date and time
```

-   YEAR(): SQLite doesn't have a YEAR function, but one can use the STRFTIME function to extract the year from a date.

```{sql STRFTIME function}
SELECT STRFTIME('%Y', 'now') AS "Current Year"; -- returns the current year
```

-   TIME(): Returns the time in 'HH:MM' format.

```{sql TIME function}
SELECT TIME('now') as "Current Time"; -- returns the current time
```

```{sql CURRENT_DATE function }
SELECT CURRENT_DATE as "Current Date"; -- returns the current date

```

```{sql CURRENT_TIME function }
SELECT CURRENT_TIME as "Current Time"; -- returns the current time

```

```{sql CURRENT_TIMESTAMP function }
SELECT CURRENT_TIMESTAMP as "Current Time and Date"; -- returns the current date and time

```

```{sql}

SELECT status_date as "Status Date" from order_history;

```

```{sql}

SELECT customer_id as "Customer ID", order_date as "Order Date" from cust_order WHERE order_date BETWEEN '2023-11-01'
and '2024-05-01' ORDER BY order_date DESC;
```

SELECT customer_id as "Customer ID", order_date as "Order Date" from cust_order WHERE order_date \< Now();

The above SQL code isn't possible as there isn't a Now() function in SQLite.

```{sql}

SELECT customer_id as "Customer ID", order_date as "Order Date" from cust_order WHERE order_date < CURRENT_TIMESTAMP;

```

```{sql}

SELECT customer_id as "Customer ID", order_date as "Order Date" from cust_order WHERE order_date > CURRENT_TIMESTAMP;

```

SQLite doesn't have a YEAR() function but it does have a TIME() function to use.

```{sql}
SELECT customer_id as "Customer ID", order_date as "Order Date" from cust_order WHERE TIME(order_date) > TIME(CURRENT_TIMESTAMP);

```

## 2 - Common SQL String Functions

The function SUBSTRING() returns a part of a character string SUBSTRING(*string, start, length*)

```{sql using substring}

select title as "Book Title" from book WHERE SUBSTRING(Title,1,2) = 'Ro'

```

The CONCAT(*string1, string2,....,string_n*) function joins two or more strings together

```{sql using concat}

select CONCAT(first_name,' ',last_name) AS "Full Name" from customer

```

The UPPER() and LOWER() functions will return strings as upper case or lower case, respectively.

```{sql using the UPPER function}
select UPPER(CONCAT(first_name,' ',last_name)) AS "Full Name" from customer
```

```{sql using the LOWER function}
select LOWER(CONCAT(first_name,' ',last_name)) AS "Full Name" from customer
```


The REPLACE() function replaces a substring with another substring - REPLACE(*string, old_string, new_string*)

```{sql Using the REPLACE function }
select REPLACE(language_id, '1', "English") as Language from book where language_id = '1'
```

