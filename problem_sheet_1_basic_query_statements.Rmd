---
title: "SQL CoP Problem Sheet 1 - Basic Query Statements"
author: "George Melrose: gam55@cam.ac.uk (Research Information Office)"
output: pdf_document
---

\section{Introduction}

These problems aim to test your basic SQL knowledge, steadily building up in complexity. The questions and solutions are common ones you will come across when querying different datasets. For the purposes of this series of problem sheets, a database of dummy Marathon results data has been generated. More information on the \textbf{Marathon} database is presented below.

The concepts tested in this sheet are covered by the LinkedIn learning course \textbf{SQL Server Fundamentals: Master Basic Query Techniques} - (<https://www.linkedin.com/learning/sql-server-fundamentals-master-basic-query-techniques>) .

\subsection{Useful Prepatory Resources}

In addition to this problem sheet, there are two useful resources you can draw upon to better understand these SQL concepts:

- \textbf{Two RMarkdown documents} - one to generate some dummy 'Universities' data (<https://github.com/georgemelrose/SQL_Practice/blob/main/0_generating_databasestar_dummy_data.Rmd>). This was copied from the excellent SQL learning resource databasestar (<https://github.com/bbrumm/databasestar/tree/main/sample_databases/sample_db_university/sqlite>). 

  The other document is an RMD HTML I generated walking you through basic SQL concepts and how they can be applied   to this databasestar dummy data   (<https://github.com/georgemelrose/SQL_Practice/blob/main/01_Basic_Query_Statements.html>). 
  
- \textbf{A video presentation} - a recording of a meeting in which I presented the \textbf{Basic Query Statements} HTML , explaining key SQL concepts - (<https://universityofcambridgecloud.sharepoint.com/sites/AD_Progress/SitePages/Learning-SQL-in-a-New-Format.aspx>). This video can be found on the aforementioned page under the \textbf{SQL and R} title. \textit{Note that this can only be viewed by SQL" Community of Practice Members, email gam55@cam.ac.uk for access}.

\subsection{Marathon Database}

Firstly, the data to be put into the Marathon database was formulated from the following Python script - (<https://github.com/georgemelrose/SQL_Practice/blob/main/Dummy_Marathon_Data/marathon_data_generation.ipynb>).

The \textbf{marathon data generation} python script generates the following tables:

\textbf{1. Runners} - Randomly generate 1000 runners with names common in their locale/country, together with their birth date and sex.

\textbf{2. Events} - The 6 Major World marathons (Berlin, Boston, Chicago,London,New York City, Tokyo), with an event per year from 2012 to 2023. 

\textbf{3. Results} - Gives results for runners in hh:mm:ss format, ensuring there aren't duplicate results for each runner per event. Prevents any results breaking either the male marathon world-record (2:00:35 Eliud Kipchoge 2023) or the female marathon world-record (2:11:53 Brigid Kosgei 2019). Also determines, with a True/False column, if a result is elite by the male standard (below 02:15:00) or the female standard (below 02:30:00).

\textbf{4. Sponsors} - Lists the following 10 major companies that typically act as sponsors to runners - "Nike", "Adidas", "Asics", "Saucony", "Hoka","Brooks", "New Balance", "Puma", "Under Armour", "Tracksmith". 

\textbf{5. Sponsored Athletes} - A table listing the fraction of the elite athletes that have a sponsor.

\textbf{6. Training Plans Descriptions} - The descriptions of 10 different training plans and their respective lengths in weeks. 

\textbf{7. Training Plans} - The training plans of athletes. 

\subsection{Marathon Database Entity Relationship Diagram}


```{r, echo = FALSE}
knitr::include_graphics("C:/Users/gam55/Downloads/sqlite/marathon_db_ERD.JPG")
```

\section{Basic Query Statment Problems}

\textbf{Bold text} and \textit{italicized text} can easily be added with LaTeX commands.

Here is an inline equation: (E=mc\^2).

And a displayed equation:

$$
a^2 + b^2 = c^2
$$

\subsection{Single Table ‘Select’ Statements}


\textbf{Q1.} - Get all the tables in the database, inspect their layout, and get the first 5 rows of each table?

\textbf{Solutions} - 

\textbf{.tables} -  to get all the tables. 

\textbf{.schema \textit{table}} -  to get the schema of a particular table.

\textbf{select * from \textit{table} limit 5} -  to get the first 5 rows of a particular table. 

\textbf{Q2.i.} - Obtain the full names and countries of the runners?

\textbf{Solution} - 

\textbf{select first\_name || '  ' || last\_name as full\_name, country from runners;} The \textbf{||} symbols concatenate the first_name and last_name columns into one. The \textbf{as} operator allows a column to  have a different name displayed in the query result. 

\textbf{Q2.ii.} - Find the top 10 Marathon results by time, male or female?

\textbf{Solution} - 

\textbf{select * from Results order by finish\_time asc limit 10;} The \textbf{order by} operator orders the results by whichever column is specified. The \textbf{asc} operator orders the results in ascending order, from the highest to the lowest time. 

\subsection{Filtering on Single Conditions}


\textbf{Q1} - Find the top 20 male marathon results and the top 20 female marathon results?

\textbf{Solution} - 

\textbf{select * from Results where sex= 'Male' order by finish\_time asc limit 20;} 

\textbf{select * from Results where sex= 'Female' order by finish\_time asc limit 20;} 

The \textbf{where} clause filters rows based on specified conditions, in the above cases the different sexes.

\textbf{Q2.i.} - Find all the runners from Lithuania, Latvia, and Estonia?

\textbf{Solution} - 

\textbf{select * from Runners where country in ('Lithuania', 'Latvia','Estonia');} 

Using the \textbf{in} operator, rows fulfilling a list can be found. 

\textbf{Q2.ii.} - Find all the runners \textit{not} from Poland, Czechia, Slovakia or Hungary?

\textbf{Solution} - 

\textbf{select * from Runners where country not in ('Poland','Czechia','Slovakia','Hungary');} 

Using \textbf{not} in conjunction with the \textbf{in} operator, rows not fulfilling a list can be found. 

\textbf{Q3.i.} - Find all the runners whose names begin with 'J'?

\textbf{Solution} - 

\textbf{select * from Runners where first\_name like 'J\%';}

Using \textbf{where} clause in conjunction with the \textbf{like} operator, rows with a first name beginning with J can be found. Note that in string matching, 'string%' find a pattern at the beginning of a string. '%string' means finding a pattern at the end of a string. 

\textbf{Q3.ii.} - Find all the runners whose names don't with 'J'?

\textbf{Solution} - 

\textbf{select * from Runners where first\_name not like 'J\%';}

The answer is exactly the same as in part i. albeit with the \textbf{not} operator to signify everything \textit{not} fulfilling the condition.


\textbf{Q3.iii.} - Find all the runners whose surnames contain 'son'?

\textbf{Solution} - 

\textbf{select * from Runners where last\_name  like '\%son\%';}

In this solution, all the matching rows that \textit{contain} the son string regardless where it is in the names are found by wrapping the string in \textbf{\%} signs in the query code. 

\textbf{Q4.i.} - Gather all training plans that have a length between 10 and 12 weeks?

\textbf{Solution} - 

\textbf{select * from Training\_Plans\_Descriptions where plan\_length\_weeks between 10 and 12;}

The \textbf{between} operator together with the required numerical parameters and the \textbf{and} operator

\textbf{Q4.ii.} - Gather all training plans that have a length less than 12 weeks?

\textbf{Solution} - 

\textbf{select * from Training\_Plans\_Descriptions where plan\_length\_weeks <12;}

The less than \textbf{<} operator after the \textbf{where} clause fetches results below a certain numerical threshold, 12 in this case. 

\textbf{Q4.iii.} - Gather all training plans that have a length more than 12 weeks?

\textbf{Solution} - 

\textbf{select * from Training\_Plans\_Descriptions where plan\_length\_weeks >12;}

The greater than \textbf{>} operator after the \textbf{where} clause fetches results above a certain numerical threshold, 12 in this case. 

\textbf{Q4.iv.} - Gather all training plans that have a length more than or equal to 12 weeks?

\textbf{Solution} - 

\textbf{select * from Training\_Plans\_Descriptions where plan\_length\_weeks >=12;}

The greater than or equals to \textbf{>=} operator after the \textbf{where} clause fetches results above or equal to a certain numerical threshold, 12 in this case. 

\subsection{Filtering on Multiple Conditions}

\textbf{Q1.i.} - Find all female runners from the United Kingdom born in the 20th century?

\textbf{Solution} - 

\textbf{select * from Runners where sex = 'Female' and country = 'United Kingdom' and date\_of\_birth > 01-01-2000;}

The greater than  \textbf{>} operator is used, converse to normal logic, to find dates \textit{less than} 1st January 2000. 

\textbf{Q1.ii.} - Find all male runners from Brazil born in 1997?

\textbf{Solution} - 

\textbf{select * from Runners where sex = 'Male' and country = 'Brazil' and date\_of\_birth between '1997-01-01' and '1997-12-31'}

In this solution, despite the date column having the format yyyy-mm-dd we can still whittle the results down to the year. Using the \textbf{between} and \textbf{and} operators, together with the date range we seek, those rows fulfilling the question's conditions can be found. 

\textbf{Q2.} - Find all runners whose names begin with the letters G or J?

\textbf{Solution} - 

\textbf{select first\_name || '  ' || last\_name as full\_name from Runners where first\_name like 'J\%' or first\_name like 'G\%';}

As in the 'Filtering on Single Conditions' section, string matching and the \textbf{where} operator are used to obtain rows fulfilling these multiple conditions. 

\subsection{Single Inner Joins}

```{r, echo = FALSE, out.width="25cm", out.height="15cm"}
knitr::include_graphics("C:/Users/gam55/Downloads/joins.png")
```


\textbf{Q1.} - Obtain the full names of all 'elite' runners?

\textbf{Solution} - 

\textbf{select first\_name || '  ' || last\_name as full\_name from Runners inner join Results on Runners.runner\_id = Results.runner\_id where is\_elite = 'True';}

Utilising the \textbf{concatenation operator} \textbf{||}  again, the full name of each runners is obtained. A single inner join with the Results table allows for a filter on the condition of 'is_elite' to be made. 

\textbf{Q2.} - Find the the following information for runners of any of the Boston Marathon events in the database: runner_id; finish_time; sex; is_elite?

\textbf{Solution} - 

\textbf{select runner\_id, finish\_time,sex, is\_elite from Results inner join Events on Events.event\_id = Results.event\_id where event = 'Boston Marathon';}

The 4 necessary columns are selected from the Results table, which is tehn joined on to the Events table by the column they have in common - event_id. Filtering specifically down to the Boston Marathon events is done by using a \textbf{where} clause. 

\subsection{Multiple Inner Joins}

\textbf{Q1.} - Obtain the full names of all 'elite' runners as well as their finish times, position, and sex? Additionally, gather the events and event dates when these elite times were made?

\textbf{Solution} - 

\textbf{select first\_name || '  ' || last\_name as full\_name, finish_time,  from Runners inner join Results on Runners.runner\_id = Results.runner\_id where is\_elite = 'True';}